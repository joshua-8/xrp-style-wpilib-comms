#pragma once

// reference: https://github.com/wpilibsuite/allwpilib/tree/main/simulation/halsim_xrp

#include <Arduino.h>

#define XRP_TAG_MOTOR 0x12
#define XRP_TAG_SERVO 0x13
#define XRP_TAG_DIO 0x14
#define XRP_TAG_ANALOG 0x15
#define XRP_TAG_GYRO 0x16
#define XRP_TAG_ACCEL 0x17
#define XRP_TAG_ENCODER 0x18

template <typename T>
struct xrp_type_tag;
template <typename T>
struct tag_type;

typedef struct {
    uint8_t id;
    float value; // -1 to 1
} xrp_motor_t;
template <>
struct tag_type<xrp_motor_t> {
    static constexpr uint8_t value = XRP_TAG_MOTOR;
    static constexpr bool hasId = true;
};

typedef struct {
    uint8_t id;
    float value; // 0 to 1
} xrp_servo_t;
template <>
struct tag_type<xrp_servo_t> {
    static constexpr uint8_t value = XRP_TAG_SERVO;
    static constexpr bool hasId = true;
};

typedef struct {
    uint8_t id;
    bool value; // true or false
} xrp_dio_t;
template <>
struct tag_type<xrp_dio_t> {
    static constexpr uint8_t value = XRP_TAG_DIO;
    static constexpr bool hasId = true;
};

typedef struct {
    uint8_t id;
    float value;
} xrp_analog_t;
template <>
struct tag_type<xrp_analog_t> {
    static constexpr uint8_t value = XRP_TAG_ANALOG;
    static constexpr bool hasId = true;
};

typedef struct {
    float rate_x; // degrees per second
    float rate_y; // degrees per second
    float rate_z; // degrees per second
    float angle_x; // degrees
    float angle_y; // degrees
    float angle_z; // degrees
} xrp_gyro_t;
template <>
struct tag_type<xrp_gyro_t> {
    static constexpr uint8_t value = XRP_TAG_GYRO;
    static constexpr bool hasId = false; // Gyro does not have an ID field
};

typedef struct {
    float accel_x; // g
    float accel_y; // g
    float accel_z; // g
} xrp_accel_t;
template <>
struct tag_type<xrp_accel_t> {
    static constexpr uint8_t value = XRP_TAG_ACCEL;
    static constexpr bool hasId = false; // Accelerometer does not have an ID field
};

typedef struct {
    uint8_t id;
    int32_t count;
    uint32_t period_numerator;
    uint32_t period_denominator;
} xrp_encoder_t;
template <>
struct tag_type<xrp_encoder_t> {
    static constexpr uint8_t value = XRP_TAG_ENCODER;
    static constexpr bool hasId = true;
};

#define TYPE_TO_TAG_VAL(type) (tag_type<type>::value)

/*
// Macro to register a send callback for a float variable, using a struct type with .id and .value fields
#define XSWC_REGISTER_SEND_TYPE_ID_VARIABLE(type, id_val, float_var) \
    xswc.registerCallbackToSendData<type>([]() { \
        type temp; \
        temp.id = (id_val); \
        temp.value = (float_var); \
        return temp; \
    });

    // Macro to register a send callback for a float variable, using a struct type with .id and .value fields
#define XSWC_REGISTER_SEND_TYPE_ID_VARIABLE(type, id_val, float_var) \
    xswc.registerCallbackToSendData<type##_t>([]() { \
        type##_t temp; \
        temp.id = (id_val); \
        temp.value = (float_var); \
        return temp; \
    });

    extern float myMotorOutput;
XSWC_REGISTER_SEND_TYPE_ID_VARIABLE(xrp_motor, 1, myMotorOutput)
// Expands to use xrp_motor_t as the type

*/

// TODO: DELETE

// template <typename T>
// void XSWC::registerCallbackToReceiveData(void (*rxCallback)(T))
// {
//     // save XRP Tag number and a function pointer to the newly registered callback function
//     receivers.push_back({ TYPE_TO_TAG_VAL(T), // xrp-datatypes.h defines TYPE_TO_TAG_VAL macro to convert a type to an XRP Tag number using template specialization
//         // create a lambda function that captures the function pointer called "rxCallback"
//         [rxCallback](const void* ptr) { // the lambda function takes a void * pointer, so we can pass any type of data
//             // this is inside the lambda function, which can be retrieved from the list of callbacks and called when data is received
//             rxCallback(*static_cast<const T*>(ptr)); // call the callback function with the data received (casting the data to the correct type for the callback function)
//         } });
// }

// template <typename T>
// void XSWC::registerCallbackToSendData(T (*txCallback)())
// {
//     // save XRP Tag number and a function pointer to the newly registered callback function
//     senders.push_back({ TYPE_TO_TAG_VAL(T), // xrp-datatypes.h defines TYPE_TO_TAG_VAL macro to convert a type to an XRP Tag number using template specialization
//         // create a lambda function that captures the function pointer called "txCallback"
//         [txCallback]() -> const void* { // the lambda function returns a const void * pointer, so we can return any type of data
//             return static_cast<const void*>(data()); // call the callback function and return the data as a const void * pointer
//         } });
// }
